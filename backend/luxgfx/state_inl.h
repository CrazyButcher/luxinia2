// Copyright (C) 2004-2011 Christoph Kubisch
// This file is part of the "Luxinia Engine".
// For conditions of distribution and use, see copyright notice in LICENSE.txt

#include <luxgfx/luxgfx.h>
#include <luxcore/scalarmisc.h>

typedef enum lxGLCompareMode_e{
  LUXGL_COMPARE_NEVER = GL_NEVER,
  LUXGL_COMPARE_LESS = GL_LESS,
  LUXGL_COMPARE_EQUAL = GL_EQUAL,
  LUXGL_COMPARE_LEQUAL = GL_LEQUAL,
  LUXGL_COMPARE_GREATER = GL_GREATER,
  LUXGL_COMPARE_NOTEQUAL = GL_NOTEQUAL,
  LUXGL_COMPARE_GEQUAL = GL_GEQUAL,
  LUXGL_COMPARE_ALWAYS = GL_ALWAYS,
  LUXGL_COMPARE_DONTEXECUTE = 0xFFFFFFFFu,
  LUXGL_COMPARES = 9,
}lxGLCompareMode_t;

typedef enum lxGLAccessMode_e{
  LUXGL_ACCESS_READ = GL_READ_ONLY,
  LUXGL_ACCESS_WRITE = GL_WRITE_ONLY,
  LUXGL_ACCESS_READWRITE = GL_READ_WRITE,
  LUXGL_ACCESS_WRITEDISCARD = GL_WRITE_ONLY,
  LUXGL_ACCESS_WRITEDISCARDALL = GL_WRITE_ONLY,
  LUXGL_ACCESSES = 5,
}lxGLAccessMode_t;

typedef enum lxGLStencilMode_e{
  LUXGL_STENCIL_KEEP = GL_KEEP,
  LUXGL_STENCIL_ZERO = GL_ZERO,
  LUXGL_STENCIL_REPLACE = GL_REPLACE,
  LUXGL_STENCIL_INCR_SAT = GL_INCR,
  LUXGL_STENCIL_DECR_SAT = GL_DECR,
  LUXGL_STENCIL_INVERT = GL_INVERT,
  LUXGL_STENCIL_INCR = GL_INCR_WRAP,
  LUXGL_STENCIL_DECR = GL_DECR_WRAP,
}lxGLStencilMode_t;

typedef enum lxGLBlendWeight_e{
  LUXGL_BLENDW_ZERO = GL_ZERO,
  LUXGL_BLENDW_ONE = GL_ONE,
  LUXGL_BLENDW_RGB_SRC = GL_SRC_COLOR,
  LUXGL_BLENDW_RGB_DST = GL_DST_COLOR,
  LUXGL_BLENDW_A_SRC = GL_SRC_ALPHA,
  LUXGL_BLENDW_A_DST = GL_DST_ALPHA,
  LUXGL_BLENDW_INVRGB_SRC = GL_ONE_MINUS_SRC_COLOR,
  LUXGL_BLENDW_INVRGB_DST = GL_ONE_MINUS_DST_COLOR,
  LUXGL_BLENDW_INVA_SRC = GL_ONE_MINUS_SRC_ALPHA,
  LUXGL_BLENDW_INVA_DST = GL_ONE_MINUS_DST_ALPHA,
}lxGLBlendWeight_t;

typedef enum lxGLBlendEquation_e{
  LUXGL_BLENDE_ADD = GL_FUNC_ADD,
  LUXGL_BLENDE_SUB = GL_FUNC_SUBTRACT,
  LUXGL_BLENDE_SUB_REV = GL_FUNC_REVERSE_SUBTRACT,
  LUXGL_BLENDE_MIN = GL_MIN,
  LUXGL_BLENDE_MAX = GL_MAX,
}lxGLBlendEquation_t;

typedef enum lxGLLogicOp_e{
  LUXGL_LOGICOP_CLEAR = GL_CLEAR,
  LUXGL_LOGICOP_SET = GL_SET,
  LUXGL_LOGICOP_COPY = GL_COPY,
  LUXGL_LOGICOP_INVERTED = GL_COPY_INVERTED,
  LUXGL_LOGICOP_NOOP = GL_NOOP,
  LUXGL_LOGICOP_INVERT = GL_INVERT,
  LUXGL_LOGICOP_AND = GL_AND,
  LUXGL_LOGICOP_NAND = GL_NAND,
  LUXGL_LOGICOP_OR = GL_OR,
  LUXGL_LOGICOP_NOR = GL_NOR,
  LUXGL_LOGICOP_XOR = GL_XOR,
  LUXGL_LOGICOP_EQUIV = GL_EQUIV,
  LUXGL_LOGICOP_AND_REVERSE = GL_AND_REVERSE,
  LUXGL_LOGICOP_AND_INVERTED = GL_AND_INVERTED,
  LUXGL_LOGICOP_OR_REVERSE = GL_OR_REVERSE,
  LUXGL_LOGICOP_OR_INVERTED = GL_OR_INVERTED,
  LUXGL_LOGICOP_ILLEGAL = 0,
}lxGLLogicOp_t;

extern lxGLCompareMode_t g_lxGLcmpModes[LUXGL_COMPARES+1];
extern lxGLAccessMode_t  g_lxGLaccessModes[LUXGL_ACCESSES];

LUX_INLINE lxGLCompareMode_t lxGLCompareMode_get(lxgCompareMode_t mode)
{
  return g_lxGLcmpModes[mode];
}

LUX_INLINE lxGLAccessMode_t lxGLAccessMode_get(lxgAccessMode_t mode)
{
  return g_lxGLaccessModes[mode];
}

static LUX_INLINE GLenum  lxScalarType_to(lxScalarType_t data)
{
  GLenum standard[LUX_SCALARS] = {
    GL_FLOAT,
    GL_BYTE,
    GL_UNSIGNED_BYTE,
    GL_SHORT,
    GL_UNSIGNED_SHORT,
    GL_INT,
    GL_UNSIGNED_INT,

    GL_HALF_FLOAT,  
    GL_DOUBLE,
    0,
  };

  return standard[data];
}